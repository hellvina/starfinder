c
expect(parsed_response.first).to have_key("name")
 parsed_response.first["name"]
 parsed_response.first[:name]
 parsed_response.first
 parsed_response
 parsed_response =  JSON.parse(response.body.first)
expect(parsed_response.to_json).to have_key(:name)
 parsed_response =  JSON.parse(response.body.first)
expect(parsed_response.to_json).to have_key(:revenue)
 parsed_response =  JSON.parse(response.body.first)
expect(parsed_response.to_json).to have_key(:revenue)
expect(parsed_response).to have_key(:revenue)
 parsed_response =  JSON.parse(response.body.first)
expect(parsed_response.first.has_key?(:name)).to be_truthy
 parsed_response =  JSON.parse(response.body.first)
expect(parsed_response.first.has_key?(:name)).to be_truthy
expect(parsed_response.first.has_key?(:revenue)).to be_truthy
 parsed_response =  JSON.parse(response.body.first)
expect(parsed_response.first).to match(hash_including('name' => 'terkey_plain'))
 parsed_response =  JSON.parse(response.body.first)
parsed_response
expect(parsed_response.first).to match(hash_including('name' => 'Bruce Wayne'))
expect(parsed_response.first).to match(hash_including('name'))
 expect(parsed_response.first).to include(:name)
parsed_response.first
 parsed_response =  JSON.parse(response.body.first)
parsed_response
 expect(parsed_response.first).to include(:name)
 expect(parsed_response).to include(:name)
expect(parsed_response).to include(have_key(:name))
parsed_response.map(&:keys).should all include(:name)
expect(parsed_response).to include(have_key(:name))
expect(parsed_response).to include(name: a_kind_of(String))
expect(parsed_response).to include(include(name: a_kind_of(String)))
expected(parsed_response).to include(include(name: a_kind_of(String)))
 parsed_response =  JSON.parse(response.body.first)
exit
expect(JSON.parse(response.body.first)).to include('name')
expect(JSON.parse(response.body.first)).to include(:name)
JSON.parse(response.body.first)
expect(JSON.parse(response.body.first)).to include(have_key(:name))
JSON.parse(response.body.first)
JSON.parse(response.body.first).first
expect(JSON.parse(response.body.first).first).to have_key(:name)
JSON.parse(response.body.first).first
JSON.parse(response.body.first).one
JSON.parse(response.body.first)
expect(JSON.parse(response.body.first)).to have_key(:name)
JSON.parse(response.body.first)
JSON.parse(response.body)
JSON.parse
JSON.parse(response.body)
response.body.first
response.body.first[1]
response.body.first[0]
response.body.firstÂ´[0]
response.body.first
response.body
response
expect(response.body.first).to have_key(:name)
response.body.first
response.body.first.one
response.body.one
response.body.first.one
response.body.first
expect(response.body).to have_key(:name)
response.body
c
 expect(response.body).to be_an(Array)
expect(response.body).to have_key(:name)
expect(response.body).to be_an(Array)
response.body
exit
expect(response.body).to be_an(Array)
response.body
response
expect(response).to be_an(Array)
exit
expect(response).to be_successful
response = github_starfinder.call(params)
expect(response).to be_successful
expect(response).to be_successful[
expect(response).to be_an(Array)
response
 response = github_starfinder.call({})
response
exit
result = github_starfinder.handle('github_username')
 described_class.new
exit
 github_starfinder
described_class
exit 
described_class.call
described_class
exit
described_class
described_class.call
 github_starfinder
continue
c
existing_repo.nil?
existing_repo = github_repository.find_by_repo_name(data)
github_repository.find_by_repo_name(data)
data
c
github_repository.create_with_github_data(data)
existing_repo.nil?
continue
exit
n
c
continue
exit
 github_repositories.by_pk(id).changeset(:update, json_object(data)).commit
id
data.name
data
id
continue
exit
github_repositories.by_pk(2).changeset(:update, data).commit
github_repositories.by_pk(23).one
github_repositories.by_pk(2).changeset(:update, data).commit
data
json_object(data)
github_repositories.by_pk(2).one
github_repositories.by_pk(2)
github_repositories.by_pk(2).changeset(:update, json_object(data)).commit
github_repositories.by_pk(2)changeset(:update, json_object(data)).commit
github_repositories.by_pk(id).one.changeset(:update, json_object(data)).commit
github_repositories.by_pk(data[:id]).one
github_repositories.by_pk(id).one
github_repositories.by_pk(id)
github_repositories.by_pk(id).changeset(:update, json_object(data)).commit
id = data[:id]
data[:id]
data.id
github_repositories.by_pk(data[:id]).changeset(:update, json_object(data)).commit
data[:id]
data[:name]
exit
data
data[:name]
data[:id]
github_repositories
continue
exit
repositories.each { |data| github_repository.update(data) }
repositories
continue
